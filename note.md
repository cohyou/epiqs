# epiqs 設計ノート

## 雑多な記述

read macroを書きたいという気持ちがあるが、そのためには、文字列処理関数から始めないといけない。仕方ないか。

## プリミティブ

- `;` Unit
- `"`で始まり`"`で終わるものが文字列。
- `|`で始まると、cons扱い。引数が2つあるとみなす。
- `.`で始まると、consで2つ目の引数が`;`だとみなす。
- `:`は唯一の中置記法。
  - `|`や`.`より結合度は強く、結果として小さい単位でconsを作る。
  - また、右結合である（Haskellと同様）。
- 引数が3つ以上の場合は、普通は`(a b c d)`となるが、
  - これはつまり `|! a |~ b |~ c .~ d` もしくは
  - `a :! b :~ c :~ d :~ ;` になる。
- 更にやるなら
  - `|! .$ "a" |~ .$ "b" |~ .$ "c" .~ .$ "d"`
  - `.$ "a" :! .$ "b" :~ .$ "c" :~ .$ "d" :~ ;` になる。


## cons cellタイプ

- `!` apply
- `?` condition
- `^` metadata? (これはどうしようか)
- `$` symbol
- `%` environment
- `*` tuple
- `\` data type
- `#` return
- `~` cons


## 文字列に関して

- UTF-8でいきたい
- `'` ... `'` なのか `"` ... `"` なのか


## リードマクロ定義関数を例に

```
(set-macro-charactor #\'
  #'(lambda (stream char)
      (list 'quote (read stream t nil t))))
```

```
|! set-macro-charactor #\'
   |\ .% 2
      |! list ['quote |! read [_1 T N T]]
```

## streamに関して

結局、これはバイト列である。そして、リストではない。ベクタである。
ベクタという概念を導入しないといけないところは、大きな判断となりうる。
まあ、言語内で書く必要は必ずしもないのだけれど。

`(! a)`をapplyにして、`()`が普通のリスト、`[]`がベクタでもいいのかもね。

そうなると
```
(! .# set-macro-charactor '
   |\ .% 2
      |! .# list (quote |! .# read (_1 T N T)))
```
になる気もする。

`a`がsymbol, `'a'`がトークン, `"a"`が文字列にします？
streamで流れてくるのは？まあ、普通に考えるとUTF-8のbytestreamがあって、それがトークン列になって、そしてそれがpiqのオブジェクトになる、というのが普通の気がする。

Common Lispのリードマクロは、それらをぶっちぎって、UTF-8のbytestreamをオブジェクトにさせようとしている。少なくともread関数はそうである。


## メタデータ？

色々、AST上に付加データをつけたいようだ（典型的なものは、コード行の位置）。
ElixirのASTは、全てシンボル、メタデータ、引数リストの順番になっている。
しかしまあ、`|!`に関してはpとqが関数と引数リストと決まっているので、オプションを付ける位置が難しい。でもまあ、正直、コマンドラインオプションに関しても、関数側につけたい時と、引数側につけたい時があるような気もする。「ファイル終端に達した時にエラーを返すべきか」「起こさないなら何の値を返すか」「readを呼び出している間にもreadが呼び出されるかどうか」今回の場合は、全て関数側のような気もする。
```
(! .# set-macro-charactor '
   |\ .% 2
      |! .# list [quote |! |# read {recursive: T throw-on-eof: T} .~ .# _1])
```

長くなったけれど、本質的にわかりやすくなった気がする。 もちろん、これをどんな風にわかりやすくかけるようにするか、という問題はまだ残っている。

思いつきだけだが、一応かっこの数を減らしておく。
```
(! .# set-macro-charactor '
   |\ .% 2
      |! .# list [quote |! |# read, recursive, throw-on-eof .~ .# _1])

```

ところで、ここで暗黙的に導入した`#`に関しては、元々slice要員だったものである。
pythonみたいに書きたいな、ということで。
ちなみに@""もコメントとしたい気がしている。

```
@"return 1"
|# 0 [1 2 3 4 5]

@"return 2"
|# 1 [1 2 3 4 5]

@"return [3 4]"
|# 2:4 [1 2 3 4 5]

@"return [1 3 5]"
|# 0:5:2 [1 2 3 4 5]

@"return 1"
|# P [1 2 3 4 5]

@"return [2 3 4 5]"
|# Q [1 2 3 4 5]
```

本題からは外れるが、この場合`:`そのものを単独では`:^`とみなす、というルールが追加されそう。仕方ない気もする。

で、このルールに追加して、最初の引数がシンボルだった場合には、名前解決をしようとさっき思いついたというわけである。シンボルと辞書dictがきたら、オプションとみなす、と。
```
@"get func"
.# identity
@"get func with option"
|# read {recursive: T} .\ _1
```

これを入れると随分`#`の範囲が広くなるイメージがあるが、まあ、良いのでは。

もし、嫌なら`&`でもいいかもね。

## 名前空間の話

`$`を使うと、シンボルを登録できるのかもしれないが、パッケージ関連というか、モジュール関連の話はしていない。どこにあるシンボル、という話であれば、モジュールも指定したい。
基本的には`|$ シンボル名 対応する内容`という感じである。
単にソースコード上で書かれたアルファベットで始まるものをトークンとみなすのであれば、それをシンボル扱いするオペレータも必要な気がするが、それは少しやりすぎなのかもしれない（だって、実際のプログラミングで「トークンがほしい」なんて事態はそうそう起こらないと思われるので）。
```
|$ package-name:function-name function
```
でいいのか。スッキリ。やっぱり`:`は便利だな。


## レコードの話

`:`つながりで。先ほどは暗黙的に出してしまったが、`{a:b c:d}`的なものも、<br>
実際には `|* a:b .* c:d` と分解される気がする。


## enumは`+`？

余談を思いついたが、`*`をtupleに使うのであれば、enumには`+`だろうか？<br>
つまり、`|+ [a b c d]` がenumだろうか。なんか違うな。TaPLを読み返せ。と思ったが手元にない。
必死に思い出してみるが、型としては足し算、つまりandではなくorだ、という話だ。
しかし、そこにいるメンバーはそれぞれ、Unit型としてみなす、という話だったはず。

## 型指定

`:`の話でさらに何かあった気がするのだが、思い出した。型指定だ。
`%`の正体が何なのかも決めないといけないが、それは次の項で。
でも、特別なオペレータを用意せずとも、シンボルが来るべき位置にconsが来てたら型宣言？しかしそれは、そのシンボルにつけたい他の情報に型情報を優先させる、という意味だと思うので、少しだけためらう（別に型を一番優先させるのは何もおかしいことではないはず）。
例えば`a, type:int`のように。でもうざいなあ。
`a=1:int`みたいに書けたらいいんやろけど、なかなかそうは問屋がおろさない。
それか、`symbol default:type`みたいにする？

## `%`
ちょっと絡んで来るので、上記の型指定からそのまま続けます。<br>
`|% symbol default:type`という風に、`|%`の後のルールにすればいい気がする。まあ、これは一つぶんなので、ちょっと気になりますけど。
勝手に面倒になって`.% 2`とかで引数が二つあるよ、みたいなことにしてしまったのだが、これをやるとしても一番簡単な書き方になるだろう。結局`|$`はどうなるんかな。どうもここが整合性がない。
```
|% |$ symbol default:type
|% symbol,default:type
|% symbol,:type
|% symbol,default:
```
単なる思いつきだが、`,`を`=`にしてみるというのもアリなんかな。
```
|% |$ symbol default:type
|% symbol=default:type
|% symbol=:type
|% symbol=default:
```
書きながら模索しているが、「追加情報」をつけるオペレータがあればいい気がする。次にあげるメタデータとPとQが反対になるが、それ以外は同じである。
```
@"metadata (info is first)"
|% |^ default:type symbol
|% |^ :type symbol
|% |^ default: symbol

@"metadata (info is last)"
|% |_ symbol default:type
|% |_ symbol :type
|% |_ symbol default:
```
記号が気にくわないので、以下に変更でもありかもしれない。
```
@"metadata (info is first)"
|% |< default:type symbol
|% |< :type symbol
|% |< default: symbol

@"metadata (info is last)"
|% |> symbol default:type
|% |> symbol :type
|% |> symbol default:
```
まあ、でも`|>`の方は
```
@"metadata (info is last)"
|% symbol, default:type
|% symbol, :type
|% symbol, default:
```
と書きたいし、これだと
```
@"metadata (info is last)"
|% module:symbol, default:type
|% module:symbol, :type
|% module:symbol, default:
```
のようになっても便利である。
まあ、これは`=`を使って、
```
@"metadata (info is last)"
|% symbol=default:type
|% symbol=:type
|% symbol=default
```
でもいいかも。`=`の後だと一つのconsが来るとみなして,`,`の後だとdictだとみなす、みたいなのということです。
```
@"metadata (info is last)"
|% symbol, default:type
|% symbol, :type
|% symbol, default
```
まだ整理されていないが、`,`は`:`みたいに結合力が強いやつかな、もちろん`=`もやけど。<br>
よく考えてみるとtupleを`,`で作れるのは、Pythonやな。Python偉大やな。ちょっと違うけど。
ここだと、`:`が一番強くて、`,`が次やね。


## 本当のメタデータ

行数などの本来のメタデータはどうなるのか。ASTになった時に、勝手につくとはいえ、<br>
`|^ {row: 21}`をどこに位置させるのか。しかしそれは要素の「外側」につく気がする。<br>
`|^ {entrypoint}`なのも同様。しかし、それならいっそ<br>
`@{entrypoint row:21}`とかの方が潔くないか。

`@`の後に文字列ならばコメント、dictならばメタデータというのは悪くない。


## コメント案

どーでもいいが`||`にしたら、それを丸ごとコメントにできる。一つなら当然`.|`。<br>
もしくは`.|`の代わりに`..`。これは完全にお遊びの範疇だが。


## 例外というか、エラー処理というか


## 遅延評価
これはそもそも、評価、というか、正確にはapplyのタイミングを決めるのはこちらなので、特に問題ないように思える。「リストの最初の引数を関数とみなして、実行する」という仕様がなければ特に気にする必要はない。


## 非同期処理 async/await的な


## で、マクロをどのように実装するのか
