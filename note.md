# epiqs 設計ノート

## 雑多な記述

read macroを書きたいという気持ちがあるが、そのためには、文字列処理関数から始めないといけない。仕方ないか。

## プリミティブ

- `;` Unit
- `"`で始まり`"`で終わるものが文字列。
- `|`で始まると、cons扱い。引数が2つあるとみなす。
- `.`で始まると、consで2つ目の引数が`;`だとみなす。
- `:`は唯一の中置記法。
  - `|`や`.`より結合度は強く、結果として小さい単位でconsを作る。
  - また、右結合である（Haskellと同様）。
- 引数が3つ以上の場合は、普通は`(a b c d)`となるが、
  - これはつまり `|! a |~ b |~ c .~ d` もしくは
  - `a :! b :~ c :~ d :~ ;` になる。
- 更にやるなら
  - `|! .$ "a" |~ .$ "b" |~ .$ "c" .~ .$ "d"`
  - `.$ "a" :! .$ "b" :~ .$ "c" :~ .$ "d" :~ ;` になる。


## cons cellタイプ

- `!` apply
- `?` condition
- `^` metadata? (これはどうしようか)
- `$` symbol
- `%` environment
- `*` tuple
- `\` data type
- `#` return
- `~` cons


## 文字列に関して

- UTF-8でいきたい
- `'` ... `'` なのか `"` ... `"` なのか


## リードマクロ定義関数を例に

```
(set-macro-charactor #\'
  #'(lambda (stream char)
      (list 'quote (read stream t nil t))))
```

```
|! set-macro-charactor #\'
   |\ .% 2
      |! list ['quote |! read [_1 T N T]]
```

## streamに関して

結局、これはバイト列である。そして、リストではない。ベクタである。
ベクタという概念を導入しないといけないところは、大きな判断となりうる。
まあ、言語内で書く必要は必ずしもないのだけれど。

`(! a)`をapplyにして、`()`が普通のリスト、`[]`がベクタでもいいのかもね。

そうなると
```
(! .# set-macro-charactor '
   |\ .% 2
      |! .# list (quote |! .# read (_1 T N T)))
```
になる気もする。

`a`がsymbol, `'a'`がトークン, `"a"`が文字列にします？
streamで流れてくるのは？まあ、普通に考えるとUTF-8のbytestreamがあって、それがトークン列になって、そしてそれがpiqのオブジェクトになる、というのが普通の気がする。

Common Lispのリードマクロは、それらをぶっちぎって、UTF-8のbytestreamをオブジェクトにさせようとしている。少なくともread関数はそうである。


## メタデータ？

色々、AST上に付加データをつけたいようだ（典型的なものは、コード行の位置）。
ElixirのASTは、全てシンボル、メタデータ、引数リストの順番になっている。
しかしまあ、`|!`に関してはpとqが関数と引数リストと決まっているので、オプションを付ける位置が難しい。でもまあ、正直、コマンドラインオプションに関しても、関数側につけたい時と、引数側につけたい時があるような気もする。「ファイル終端に達した時にエラーを返すべきか」「起こさないなら何の値を返すか」「readを呼び出している間にもreadが呼び出されるかどうか」今回の場合は、全て関数側のような気もする。
```
(! .# set-macro-charactor '
   |\ .% 2
      |! .# list [quote |! |# read {recursive: T throw-on-eof: T} .~ .# _1])
```

長くなったけれど、本質的にわかりやすくなった気がする。 もちろん、これをどんな風にわかりやすくかけるようにするか、という問題はまだ残っている。

思いつきだけだが、一応かっこの数を減らしておく。
```
(! .# set-macro-charactor '
   |\ .% 2
      |! .# list [quote |! |# read, recursive, throw-on-eof .~ .# _1])
```

ところで、ここで暗黙的に導入した`#`に関しては、元々slice要員だったものである。
pythonみたいに書きたいな、ということで。
ちなみに@""もコメントとしたい気がしている。

```
@"return 1"
|# 0 [1 2 3 4 5]

@"return 2"
|# 1 [1 2 3 4 5]

@"return [3 4]"
|# 2:4 [1 2 3 4 5]

@"return [1 3 5]"
|# 0:5:2 [1 2 3 4 5]

@"return 1"
|# P [1 2 3 4 5]

@"return [2 3 4 5]"
|# Q [1 2 3 4 5]
```

本題からは外れるが、この場合`:`そのものを単独では`:^`とみなす、というルールが追加されそう。仕方ない気もする。

で、このルールに追加して、最初の引数がシンボルだった場合には、名前解決をしようとさっき思いついたというわけである。シンボルと辞書dictがきたら、オプションとみなす、と。
```
@"get func"
.# identity
@"get func with option"
|# read {recursive: T} .\ _1
```

これを入れると随分`#`の範囲が広くなるイメージがあるが、まあ、良いのでは。

もし、嫌なら`&`でもいいかもね。

## 名前空間の話

`$`を使うと、シンボルを登録できるのかもしれないが、パッケージ関連というか、モジュール関連の話はしていない。どこにあるシンボル、という話であれば、モジュールも指定したい。
基本的には`|$ シンボル名 対応する内容`という感じである。
単にソースコード上で書かれたアルファベットで始まるものをトークンとみなすのであれば、それをシンボル扱いするオペレータも必要な気がするが、それは少しやりすぎなのかもしれない（だって、実際のプログラミングで「トークンがほしい」なんて事態はそうそう起こらないと思われるので）。
```
|$ package-name:function-name function
```
でいいのか。スッキリ。やっぱり`:`は便利だな。


## レコードの話

`:`つながりで。先ほどは暗黙的に出してしまったが、`{a:b c:d}`的なものも、<br>
実際には `|* a:b .* c:d` と分解される気がする。


## enumは`+`？

余談を思いついたが、`*`をtupleに使うのであれば、enumには`+`だろうか？<br>
つまり、`|+ [a b c d]` がenumだろうか。なんか違うな。TaPLを読み返せ。と思ったが手元にない。
必死に思い出してみるが、型としては足し算、つまりandではなくorだ、という話だ。
しかし、そこにいるメンバーはそれぞれ、Unit型としてみなす、という話だったはず。

## 型指定

`:`の話でさらに何かあった気がするのだが、思い出した。型指定だ。
`%`の正体が何なのかも決めないといけないが、それは次の項で。
でも、特別なオペレータを用意せずとも、シンボルが来るべき位置にconsが来てたら型宣言？しかしそれは、そのシンボルにつけたい他の情報に型情報を優先させる、という意味だと思うので、少しだけためらう（別に型を一番優先させるのは何もおかしいことではないはず）。
例えば`a, type:int`のように。でもうざいなあ。
`a=1:int`みたいに書けたらいいんやろけど、なかなかそうは問屋がおろさない。
それか、`symbol default:type`みたいにする？

## `%`
ちょっと絡んで来るので、上記の型指定からそのまま続けます。<br>
`|% symbol default:type`という風に、`|%`の後のルールにすればいい気がする。まあ、これは一つぶんなので、ちょっと気になりますけど。
勝手に面倒になって`.% 2`とかで引数が二つあるよ、みたいなことにしてしまったのだが、これをやるとしても一番簡単な書き方になるだろう。結局`|$`はどうなるんかな。どうもここが整合性がない。
```
|% |$ symbol default:type
|% symbol,default:type
|% symbol,:type
|% symbol,default:
```
単なる思いつきだが、`,`を`=`にしてみるというのもアリなんかな。
```
|% |$ symbol default:type
|% symbol=default:type
|% symbol=:type
|% symbol=default:
```
書きながら模索しているが、「追加情報」をつけるオペレータがあればいい気がする。次にあげるメタデータとPとQが反対になるが、それ以外は同じである。
```
@"metadata (info is first)"
|% |^ default:type symbol
|% |^ :type symbol
|% |^ default: symbol

@"metadata (info is last)"
|% |_ symbol default:type
|% |_ symbol :type
|% |_ symbol default:
```
記号が気にくわないので、以下に変更でもありかもしれない。
```
@"metadata (info is first)"
|% |< default:type symbol
|% |< :type symbol
|% |< default: symbol

@"metadata (info is last)"
|% |> symbol default:type
|% |> symbol :type
|% |> symbol default:
```
まあ、でも`|>`の方は
```
@"metadata (info is last)"
|% symbol, default:type
|% symbol, :type
|% symbol, default:
```
と書きたいし、これだと
```
@"metadata (info is last)"
|% module:symbol, default:type
|% module:symbol, :type
|% module:symbol, default:
```
のようになっても便利である。
まあ、これは`=`を使って、
```
@"metadata (info is last)"
|% symbol=default:type
|% symbol=:type
|% symbol=default
```
でもいいかも。`=`の後だと一つのconsが来るとみなして,`,`の後だとdictだとみなす、みたいなのということです。
```
@"metadata (info is last)"
|% symbol, default:type
|% symbol, :type
|% symbol, default
```
まだ整理されていないが、`,`は`:`みたいに結合力が強いやつかな、もちろん`=`もやけど。<br>
よく考えてみるとtupleを`,`で作れるのは、Pythonやな。Python偉大やな。ちょっと違うけど。
ここだと、`:`が一番強くて、`,`が次やね。
`a,b,c`が'|> a {b c}'は多少違和感があるが、まあ、許容範囲かなあ。
また改めて考えることにしておきましょう。


## 本当のメタデータ

行数などの本来のメタデータはどうなるのか。ASTになった時に、勝手につくとはいえ、<br>
`|^ {row: 21}`をどこに位置させるのか。しかしそれは要素の「外側」につく気がする。<br>
`|^ {entrypoint}`なのも同様。しかし、それならいっそ<br>
`@{entrypoint row:21}`とかの方が潔くないか。

`@`の後に文字列ならばコメント、dictならばメタデータというのは悪くない。


## コメント案

どーでもいいが`||`にしたら、それを丸ごとコメントにできる。一つなら当然`.|`。<br>
もしくは`.|`の代わりに`..`。これは完全にお遊びの範疇だが。
Common Lispが`|#`...`#|`を持っているので、変な話でもない。

## 例外というか、エラー処理というか

ちょっと真面目に考え始めると、やはりエラー処理（というか、例外ですね）に関して考えざるを得ない。<br>
実際にはRubyだと`begin rescue else ensure end`+`raise retry`、<br>
Pythonだと`try: except Error as e: else: finally:`+`raise`。<br>
`retry`がPython標準にはないが、どうやらdecoratorでやるみたい。
基本的には「被せて使うものだ」というイメージがあるので、
```
|& func exception
|- func exception
|_ func exception
```
とか、余っている記号でやるしかない。個人的には `|_`がいい感じ。下支えしている印象。
そしてexceptionの中身は、
```
{exception:function exception:function function}:finally
```
かなあ。tuple内最後のfunctionはPythonの`else`、最後の奴が`ensure``finally`にあたる。<br>
`raise`も必要だけど、これはどうしよう。`raise`という文字列は出したくないなあ。<br>
思いつきだが、`!?`は好きだなあ。`?!`よりは`!?`。「びっくりはてな」である。<br>
一度コードに落としてみますか。
```Python
try:
  f = open('myfile.txt')
  s = f.readline()
  i = int(s.strip())
except OSError as err:
  print("OS error: {0}".format(err))
except ValueError as err:
  print("Could not convert data to an integer.")
except:
  print("Unexpected error:", sys.exc_info()[0])
  raise
else:
  print(arg, 'has', len(f.readlines()), 'lines')
finally:  
  f.close()
```

```
|!?
  |% {f: |! open 'myfile.txt'
      s: |! readline f
      i: |! int |! strip s}
  |~
    |~
      { OSError   : |\ |! #> |! #>" ["OS error: {0}" _1]
        ValueError: |\ |! #> "Could not convert data to an integer."
        T         : |\ |~ |! #> ["Unexpected error:" |# 0 |! exc_info sys]
                          .! !?
      }
      |! #> [arg 'has' (# |! readlines f) 'lines']
    |! close f
```
結構スッキリしたはず。`|! #>`は`|!>`みたいにしてもいいかもね。


## 遅延評価

これはそもそも、評価、というか、正確にはapplyのタイミングを決めるのはこちらなので、特に問題ないように思える。<br>
「リストの最初の引数を関数とみなして、実行する」という仕様がなければ特に気にする必要はない。


## 非同期処理 async/await的な

さて、要するに、コールバック地獄になりたくない、という話です。
後、それから、Occum的なparallel処理の話もありましたね。
この二つは全然違う話ですけど。
ともかく、実行ブロックをどのように表すか、という話からは逃げられないので、まずはそれを。

上記では単に`|!`をconsで繋げている。リストだろうが同じだね。
```
|~ .! a
|~ .! b
.~ .! c
```
よく考えたら、上の例は、何も指定していないのに、実行ブロックを逐次実行にしているな。あんまり好きではない。
今度はリストで書く。これで逐次実行で最後の値を返す。
```
|# -1 |!~[.! a .! b .! c]
```
本筋ではないが、`#`を中置記法にもできたらいいなあ。
```
(|!~ [.! a .! b .! c])#-1
```
的に。まあその話は置いておいて。
この話の場合だと、組み合わせて
```
|!~- [.! a .! b .! c]
```
かもね。

そして、redux-sagaみたいにするならば、`yield`にあたるものを作る必要がある。
それから`spawn`も。

`|!_`がspawnなのはどうだろう。裏側で動いている感じ。
`|!#`がyield。一旦値をreturnするので。

他に何がいるかな。あんまり思いつかない。


## イベントの話もあった

イベントについては
- イベントハンドラの書き方（ハンドリングの仕方）
- イベントの発生のさせ方
があればよい。


まず、実行ブロックだけど、実行しない（待っている）ので、`!`は含めたくない。
```
|! |~- [.! a .! b .! c]
```
そして、NotificationCenter的なものが存在しないと話にならないので、
dispatchを行うオペレータが必要になる。
以下のどちらか。下がいいかな。
```
|>! event-name execution-block
|!< event-name execution-block

|!< event-name |~- [.! a .! b .! c] @"これはあんまり"
|!< event-name \!~-[.! a .! b .! c]
|!< event-name [~#- a b c] @"これかな !をつけると実行を開始してしまう 逐次で最後の値を返すというのだけわかればよい"
|!< event-name .\~#- [a b c] @"まずはこっち、\で始めると型や性質を変更できるというやつですね。データ型のタグ付けに近い。"
```

混乱しないように。今決めたいのは、読みやすい構文というよりは、consで書き下せる構文。<br>
つまり、もっと展開された状態が何かを決定したい。


またそれとは別の話題だが、勝手に関数に`\`を使ってしまったなあ。あんまりいけてない気がする。<br>
lambdaを何で表すか、ですなあ。実行ブロックだ、という意味では`\`でいいのか……。<br>
ただ、逐次実行だ、ということを示す`\~`ではある必要がある気がしてきた。<br>
デフォルトの`\`が逐次実行でもいいけどね。ただ、「もっとも展開された形」ではない。
ちなみにparallelは`\~`でないなら何だろう？`\&`か。なんかand感だけで選んだけど。
```
|< {!:~ #:-1} [a b c]
```
かなあ。実行形式は逐次、返すのは最後。
```
|< {!:& wait:all} [a b c]
```
かなあ。実行形式は逐次、全部終わるまで待つ、とか。今思いつきで書いた、あくまで案ですが。
じゃあ`\`は関数のままでいいんかな。まだ違和感。いや、基本単位だからいいのか。
付加情報だから`^`でもいいかも。迷うなあ。
```
|^ {!:& wait:all} [a b c] @"^にしてみた"
|^&a [a b c] @"ちょっとムリヤリやなあ"

@"どうせならこういうのは？"
|=> [a b c] {!:~ #:-1}
|=< {!:~ #:-1} [a b c]

@"+の方が足してる感はあるかも"
|+> [a b c] {!:~ #:-1}
|+< {!:~ #:-1} [a b c]
```

`+>` `+<`はいいかもしらん。


うーん、だんだん簡潔になっている気はするが、その変化をどのように実装させるのか。それが以下ですね。


## define

なんか勝手にdefineを`$`でやろうとしてましたが、よく考えると`%+`だよね。環境に足すから。<br>
そうなると、`$`の使い道がどんどんなくなっていくような気もするのですが。<br>
被せて付加情報を足すのは`+>` `+<`でできてしまうし。何だか混乱してきた。<br>
`_` `^` も余ってきたなあ。まだまだ改良の余地がありそう。

`$`は、シンボルの種類を決めることができるかも。つまり、型情報。<br>
モジュールだとか、関数だとか。ちょっと自信ありませんが。


## で、マクロをどのように実装するのか

今ここで言っているのはリードマクロではなく、通常のマクロのこと。<br>
その中でもさらに特権的に、「オペレータマクロ」というものを提唱したい。<br>
つまり、`|`か`.`かもしくは`(`...`)`の中で最初に出てくる、という形をとるシンボルのこと。<br>
偶然記号が多いですが、理論上は何でもいけるように。

引数としては、マクロとして使う文字を指定する。まあ、普通に文字列でよいのでは。<br>
`%%%+`みたいな強そうなやつで。

```
@"これはちょっと簡潔すぎる？"
|%%%+ !>
      .\ |! #> %p
```

`!>`が来たら実行する、というASTをそのまま返す。%1は後続のASTです。<br>
絶対にconsなので、多くても引数は2つ。おお。これは素晴らしい。<br>
もう少し整理すればいけそう。<br>
なるほど、結局quoteが欲しくなるのはそういうことか。<br>
ただ、最初の再帰的な発火を@に任せればよいので、これはこれですでにマクロとしてできている感じ。<br>
ちなみに、このマクロは、木の組み替え規則を書いているとも言える。<br>


## 振り返ってみて

環境が`%`なら、引数も`_1`じゃなくて`%1`なのでは

もう一度、全て再整理ですね。
