# 再整理

## 概要

そもそも気づいたが、Elixir式のASTは、結局XMLと同じなのだ。
{tag-name attributes children}
ということだ。

そして、私の動機は、できるだけ、簡潔にASTを書き下せるようにすることだ。
LispやXMLのやり方は汎用的だが、冗長だ。実用に耐えうるよう、慎重にconsの種類を選んでいきたい。

また、プログラミングのためには「英語」をある程度理解する必要がある、というのも本当はいやだ。
賛否両論あるのは前提で、できるだけ、簡潔に記号だけでASTを記述できるようにしたい。

`note.md`にはそもそも、試行錯誤をそのまま書いている。
これを逆から順に辿り、改めて整理するのがこのドキュメントの目的である。


### リテラル

数値は正規表現で書くと`([1-9][0-9]*)|0`かな。
シンボルは[a-z]+ですね。アルファベットで始まっていればシンボルだとみなす。
文字列は`'` ... `'`なのか`"` ... `"`なのかは迷っている。


### 基本のcons

まずはここから。内容的には特に何もない。
表記で使用するのは`:`。中置記法のうち、唯一のプリミティブ（としたい）。


### 任意のASTへのリンクを張る

それぞれにidが振られて、それを指定したいが、どうしよう。
現在は勝手にシステムがidを振ってしまう。それを取得したい。
AST上で親が取れる？XPathの`parent`的なものを作ればよい。
もしくは`%`だけを繋いだものを作成できれば嬉しい。


### シンボル

難しいが、`{$ 基本情報 現在の値}`でしょうか、基本的には。
基本情報は`dict`、`[name:'name' type:int8]`みたいに。nameだけは必須かな。
いや、`gensym`とかだと不要か。内部的にidがついているはずなので。
値に関しては特筆する点はない。
このpiqはキレイに`{tag-name attributes children}`の形になってますね。


### 環境

シンボルテーブル、ですね。ざっくりいうと。
`{% 環境の種類 束縛変数のリスト}`
環境の種類には「変数」「関数」(Lisp-2なら)それから「モジュール」とかが浮かぶ。
だから、本来は「環境の種類」はenumであるべきだろう。

仕様として、環境のネストが気になる。`%`は新規の環境を作成する。
ただ、環境には通常親子関係が存在する。ここら辺の仕様は迷うが、
`{% [type:variable parent:~] 束縛変数のリスト}`
親の環境を明示的に指定するようにしたい（AST上では、暗黙の動きをなくしたい）。


### lambda=コードブロック

lambdaの前に、コードブロックの定義が必要かと。
`{\ 付加情報 ブロックリスト}`
付加情報には上記の環境を追加できる。あとは、実行が逐次or並行。また、返却する値も気になる。
`{\ [%:~ order:sequential #:-1] [_1]}`
引数は数値で指定。`_1`か`%1`で指定する。


### define

環境に新しく入れる、ということなので、
{%+ symbol value}
だと簡単に話は終わるのですが、どの環境なのかを明示したい気はします。
{%+ ref-env symbol:value}
ですかね。環境の種類を書くべきでしょうし、なんなら、それらをパスで指定できるようにしたいですね。
{%+ ; symbol:value} // グローバル
{%+ func symbol:value} // 関数テーブル
{%+ variable symbol:value} // 関数テーブル
{%+ type symbol:value} // 型テーブル
とかですかね。ここは少し議論の余地がありますね。

### module

上記の議論を元に、何かモジュールを表すconsが欲しくなったので、それだけ書いておきます。
もう字が余っていないのでは？`/`ぐらいかな。てか不要かなあ。
{/ }
モジュールシステムをどのように設計できるか、ということだと思います。
ネストできるのかどうか、とかも気になります。


### apply

やっと出てきたapply。
{! 関数 [arglist...]}
ですよね。これはかんたん。
と思っていたら、optionを追加できるように。
{! 関数:[option]　[arglist...]}
optionは普通、keyword-listかな。


### condition

条件分岐は
{? condition on-truthy:on-falsy}
でよいのでは。


### tuple

{& a:b {& b:c ;}}
的なやつですね。dictとkeyword-listの区別はしてもいいけど。
[a:b c:d e:f]
{a:b c:d e:f}


### deref

参照剥がしである。ポインタ剥がしのイメージで`*`をタプルから奪いました。
でもClojureっぽく、`@`でもいいかなあ。
正確には、シンボル解決である。
`{* 追加情報 symbol}`
思いつかないが、なんかあるかなあ、追加情報。


### 取得

取得には`#`を使う。
`{# 位置情報 シーケンス}`
という感じかな。何かクエリをPathとか書けたらいいなあ。
selector的な？moduleでも同じものが使えたらいいなあ。
Pythonのslice的なものは使えるつもり。


### enumはどうしよう。
`+`を使いたいので、それで。
`{+ 追加情報 [a:b c:d e:f]}`
例によって追加情報がなんなのかは思い浮かばない。


### 埋め込み
リストの埋め込みを`,`でやろう。優先順位は`:`には負けるやつ。
`{! 関数 [option]:[arglist...]}`
は
`|! func [opt1 opt2:T]:[arg1 arg2 arg3]`
いや、なんか違う。ちょっと保留。


### metadata
`{^ 追加情報 本体}`
`+>` `+<`は一旦保留。


### comment

`..`が一行、`||` ... `||`が複数行かなあ。


### exception

`!?`は発明だと思う。一番長くなるので以下のパターンか。
`{!? {ex:func ex:func func}:finally}` func}


### 非同期処理

spawnはコードブロック`\`の中で付加情報だな。非同期かどうか、待つのか、とかね。
yieldは、むしろ`|!#`かな。返却するので。

ちなみにparallelのマクロ案は`\&`。


### イベントディスパッチ

ああ、でもこれはディスパッチテーブルの話。テーブルの話は`%`かも。
そうか、`%`の環境は、シンボルテーブルだけとは限らないのか。

`|!< event-name execution-block` ..これはマクロかも。





#### 必要なシンボルテーブル一覧

タグ
変数・関数
イベントディスパッチテーブル



#### ドットリストが作りたい

最近はClojureが流行っているようだし、私もやはり大好きなのだが、やはり特徴として現実とのバランスが良いばっかりに、
ドットリストが作れない。あくまで単体で存在するのではなく、Linked Listの部品としてのみ存在するものになってしまった。
効率が悪いとか、よくわかっている。そういうことじゃないんだ。やっぱりコンスセルで構成された言語がほしい。
いやまあ、他のLisp使えばいいんですけど。はい。うん。作りたかったんよ。他のLispはしかも効率は悪くないし。
正直上記以外はClojureはほとんど理想の構文をしている。



### 「プログラミング言語=英語」という常識に挑戦したい

これは歴史上仕方がないことだが、現在プログラミング言語を勉強するのであれば、そこに出てくるキーワードは英語から取られている。
英語を勉強しないとプログラミングが勉強できない、という風潮は少しずつでもなくなっていけばいいな、と思っている。
たまたま、英語のアルファベットが記号系として比較的少数の文字を組み合わせて書くものだったし、自然言語を模す形で書き下せればそもそもソースコードを音声として読めるし、まさにそれこそ可読性が高くなるので、大変合理的だとは思うのだが、違った形があっても良い。Pietとか、様々なビジュアルプログラミングツールが幾多現れているが、私としてはできるだけ効率性を担保したまま、できるだけいいとこ取りをしたいと考えたので、なるべくascii内の記号だけで要素を構成しようと試みた。APLみたいになるかと思ったが、よくわからない。そんなに酷くないように思えるけど、慣れの問題か。
なのでEpiqsの他に、ビジュアルプログラミングに強い興味が湧いている。
